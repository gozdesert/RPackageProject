library(fpcaCor)
library(fpcaCor)
?soft
library(fpcaCor)
soft(1, 5)
soft(3,2)
library(fpcaCor)
library(usethis)
use_build_ignore("Draft")
use_build_ignore("soft.R")
library(fpcaCor)
library(usethis)
usethis::use_vignette("fpcaCorrelation", "Getting started with R-package fpcaCor")
library(refund)
?fpca.face
fpca.face
x = matrix(10, nrow = 2)
dim(x)
x = matrix(10, nrow = 2)
x = matrix(1:10, nrow = 2)
dim(x)
d =dim(x)
d[1]
smooth.spline
library(fpcaCor)
usethis::use_package("refund", type = "Imports")
?stopifnot
stopifnot(1 == 1)
stopifnot(1 != 1)
y = NULL
stopifnot(!is.null(y))
source("~/Desktop/STAT600/fpcaCor/Draft.R", echo=TRUE)
source("~/Desktop/STAT600/fpcaCor/Draft.R", echo=TRUE)
Y = NULL
smooth_spline_mean(Y,1)
library(stats)
?colMeans
library(Matrix)
?colMeans
usethis::use_package("Matrix", type = "Imports")
usethis::use_package("stats", type = "Imports")
usethis::use_package("stats", type = "Imports")
usethis::use_package("stats", type = "Imports")
usethis::use_package("stats", type = "Imports")
J = 5
argvals <- (1:J)/J - 1/2/J
argvals
?smooth.spline
?rnorm
?matrix
usethis::use_package("base", type = "Imports")
library(fpcaCor)
importFrom("refund", "smooth.spline")
?importFrom
library(fdapace)
library("fdapace")
library(fdapace)
?FPCA
??FPCA
?fpca.face
install.packages("fdapace")
library(fdapace)
fdapace
?fdapace
??fdapace
use_package("fdapace", type = "Imports")
?colmeans
?colMeans
usethis::use_package("Matrix", type = "Imports")
devtools::document()
library(fpcaCor)
I <3 Gozde :)
print("I <3 Gozde")
print("I <3 G\:ozde")
print("I <3 G\'ozde")
print("I <3 G\'ozde")
source("~/Desktop/STAT600/fpcaCor/R/smooth_spline_mean.R", echo=TRUE)
smooth_spline_mean = function(Y = NULL, argvals = NULL, center = TRUE){
stopifnot(!is.null(Y))  #if Y = NULL, stop the function and give an error message
stopifnot(is.matrix(Y))  #if Y is not a matrix, stop the function and give an error message
data_dim <- dim(Y)
I <- data_dim[1]
J <- data_dim[2]
if (is.null(argvals))
argvals <- (1:J)/J - 1/2/J #create a numerical vector
meanX <- rep(0, J)   #create a vector of zeros
if (center) {
meanX <- colMeans(Y, na.rm = TRUE)
meanX <- smooth.spline(argvals, meanX, all.knots = TRUE)$y  #call smooth.spline function from the package refund
}
return(meanX)  #return the mean vector after smoothing
}
smooth_spline_mean = function(Y = NULL, argvals = NULL, center = TRUE){
stopifnot(!is.null(Y))  #if Y = NULL, stop the function and give an error message
stopifnot(is.matrix(Y))  #if Y is not a matrix, stop the function and give an error message
data_dim <- dim(Y)
I <- data_dim[1]
J <- data_dim[2]
if (is.null(argvals)){
argvals <- (1:J)/J - 1/2/J #create a numerical vector
}
meanX <- rep(0, J)   #create a vector of zeros
if (center){
meanX <- colMeans(Y, na.rm = TRUE)
meanX <- smooth.spline(argvals, meanX, all.knots = TRUE)$y  #call smooth.spline function from the package refund
}
return(meanX)  #return the mean vector after smoothing
}
library(refund)
library(refund)
install.packages("refund")
install.packages("refund")
library(refund)
View(smooth_spline_mean)
Y = matrix(rnorm(100), nrow = 10, ncol = 10)
smooth_spline_mean(Y, argvals = NULL)
fpca.face()
fpca.face
library(fpcaCor)
?smooth_spline_mean
library(fpcaCor)
library(fpcaCor)
library(usethis)
library(usethis)
use_testthat()
use_test("smooth_spline_mean")
?smooth.spline
fpca.face()
fpca.face()
fpca.face
?fpca.face
fpca.ssvd
fit = lm(rnorm(100) ~ rnorm(100))
Y = rnorm(100)
X = rnorm(100)
lm(Y ~ X)
preidct(lm(Y ~ X), 5)
predict(lm(Y ~ X), 5)
predict(lm(Y ~ X), xnew = data.frame(X = 5))
?predict
?predict.lm
predict(lm(Y ~ X), newdata = data.frame(X = 5))
predict(lm(Y ~ X), newdata = data.frame(X = 5), interval = "prediction")
usethis::use_package("latentcor", type = "Imports")
library(fpcaCor)
library(latentcor)
#Construct sample corr matrix Khat
# T = size of data
T = 100
gen_data(n = T, types = "con")
X = gdata$X
gdata = gen_data(n = T, types = "con")
X = gdata$X
X
?latentcor
#Construct sample corr matrix Khat
# T = size of data
T = 25
set.seed(1234)
gdata = gen_data(n = T, types = "bin", "trancated", "con")
gdata = gen_data(n = T, types = "bin", "trancated", "con", copulas = "no")
gdata = gen_data(n = T, types = "con")
X = gdata$X
X
estimate = latentcor(X, types = "con")
usethis::use_package("mgcv", type = "Imports")
library(fpcaCor)
?gaussian_copula_cor
?gaussian_copula_cor
library(fpcaCor)
?gaussian_copula_cor
library(fpcaCor)
library(fpcaCor)
?gaussian_copula_cor
library(fpcaCor)
?gaussian_copula_cor
library(fpcaCor)
library(fpcaCor)
?gaussian_copula_cor
library(fpcaCor)
?gaussian_copula_cor
library(fpcaCor)
library(fpcaCor)
library(fpcaCor)
?fpca.sc
?latentcor
library(fpcaCor)
?gaussian_copula_cor
mydata = gaussian_copula_cor(n = 100, ntime = 25)
Y = mydata$Y
Khat = mydata$Khat
library(fpcaCor)
?latentcor
X = matrix(rnorm(1000), ncol = 25)
latentcor(X, types = "con")
library(fpcaCor)
devtools::document()
library(fpcaCor)
?fpca.cor
library(fpcaCor)
X = matrix(rnorm(1000, ncol = 25))
?matrix
X = matrix(rnorm(1000), ncol = 25)
fpca.cor(X = X, types = "con", argvals = NULL, nbasis = 10, pve = 0.99, npc = NULL)
fpca.cor(X = X, types = "con", argvals = NULL, nbasis = 10, pve = 0.95, npc = NULL)
fpca.cor(X = X, types = "con", argvals = NULL, nbasis = 8, pve = 0.99, npc = NULL)
?gen_data
library(fpcaCor)
Mydata.list = gen_data(n = 100, types = rep("con", 50), showplot = TRUE)
library(latentcor)
Mydata.list = gen_data(n = 100, types = rep("con", 50), showplot = TRUE)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(fpcaCor)
plot_data = Mydata.list$plotX
plot_data
X
devtools::document()
devtools::document()
devtools::document()
library(fpcaCor)
library(fpcaCor)
?gen_data
?fpcaCor
library(fpcaCor)
NPC = outputs$npc
outputs = fpcaCor(X, pve = 0.95)
library(fpcaCor)
getAnywhere(quadWeights)
?fpcaCor
X = matrix(rnorm(1000), nrow = 50, ncol = 20)
fpcaCor(X = X, pve = 0.99)
types = "con"
mylist = latentcor(X, types = types)
library(latentcor)
mylist = latentcor(X, types = types)
Khat = mylist$Rpointwise
#now we smooth Khat to get Ktilde
# we use the code coming from fpca.sc function
dia.Khat = diag(Khat)
diag(Khat) = NA  #we ignore diagonal elements first
#Take the upper triangular part of Khat
ut.Khat = upper.tri(Khat, diag = TRUE)
ut.Khat[2, 1] <- ut.Khat[ncol(Khat), ncol(Khat) - 1] <- TRUE
#next step we need to calculate
cov.count = matrix(0, D, D)
#construct a matrix just taking the elements not equal to NA
for (i in 1:I) {
obs.points = which(!is.na(X[i, ]))
cov.count[obs.points, obs.points] = cov.count[obs.points, obs.points] + 1
}
cov.count = matrix(0, D, D)
for (i in 1:I) {
obs.points = which(!is.na(X[i, ]))
cov.count[obs.points, obs.points] = cov.count[obs.points, obs.points] + 1
}
I = nrow(X)
D = ncol(X)
nbasis = 10  #we need nbasis to choose how many columns we want for the smoothed version
mylist = latentcor(X, types = "con")
Khat = mylist$Rpointwise
#Second, we need to smooth Khat to get Ktilde by using some parts of fpca.sc code.
#Khat is symmetric we do not need to if (!useSymm) part.
#Also in the code their G.0 is our Khat
#now using the smoothing method we can actually smooth Khat
dia.Khat = diag(Khat)
diag(Khat) = NA
#Take the upper triangular part of Khat
ut.Khat = upper.tri(Khat, diag = TRUE)
ut.Khat[2, 1] <- ut.Khat[ncol(Khat), ncol(Khat) - 1] <- TRUE
#next step we need to calculate
cov.count = matrix(0, D, D)
for (i in 1:I) {
obs.points = which(!is.na(X[i, ]))
cov.count[obs.points, obs.points] = cov.count[obs.points, obs.points] + 1
}
usecov.count <- cov.count
usecov.count[2, 1] <- usecov.count[ncol(Khat), ncol(Khat) - 1] <- 0
usecov.count <- as.vector(usecov.count)[ut.Khat]
use <- as.vector(ut.Khat)
vKhat <- as.vector(Khat)[use]
#since we will use argument values NULL default, we take the part where we generate argument values
argvals = seq(0, 1, length = D)
row.vec = rep(argvals, each = D)[use]
col.vec = rep(argvals, times = D)[use]
mCov = gam(vKhat ~ te(row.vec, col.vec, k = nbasis), weights = usecov.count)
npc.0 = matrix(NA, D, D) #to get the smooth cor mat we create a matrix
spred = rep(argvals, each = D)[upper.tri(npc.0, diag = TRUE)]
library(mgcv)
help("mgcv-package")
install.packages(mgcv)
install.packages("mgcv")
install.packages("mgcv")
library(mgcv)
mCov = gam(vKhat ~ te(row.vec, col.vec, k = nbasis), weights = usecov.count)
npc.0 = matrix(NA, D, D) #to get the smooth cor mat we create a matrix
spred = rep(argvals, each = D)[upper.tri(npc.0, diag = TRUE)]
tpred =  rep(argvals, times = D)[upper.tri(npc.0, diag = TRUE)]
smVCov = predict(mCov, newdata = data.frame(row.vec = spred, col.vec = tpred))
npc.0[upper.tri(npc.0, diag = TRUE)] = smVCov
npc.0[lower.tri(npc.0)] = t(npc.0)[lower.tri(npc.0)]
Ktilde = npc.0
#now we obtain Ktilde and we want to extract the efunctions from Ktilde
# w <- quadWeights(argvals, method = integration)  There is no method called integration for this function.
w1 <- quadWeights(argvals = argvals, method = "trapezoidal") #one method to get w1
quadWeights<- function(argvals, method = "trapezoidal")
{
ret <- switch(method,
trapezoidal = {D <- length(argvals)
1/2*c(argvals[2] - argvals[1], argvals[3:D] -argvals[1:(D-2)], argvals[D] - argvals[D-1])},
midpoint = c(0,diff(argvals)),  # why is this called 'midpoint'???
stop("function quadWeights: choose either trapezoidal or midpoint quadrature rule"))
return(ret)
}
#now we obtain Ktilde and we want to extract the efunctions from Ktilde
# w <- quadWeights(argvals, method = integration)  There is no method called integration for this function.
w1 <- quadWeights(argvals = argvals, method = "trapezoidal") #one method to get w1
#now we will choose w= w1
w = w1
Wsqrt <- diag(sqrt(w))
Winvsqrt <- diag(1/(sqrt(w)))
V <- Wsqrt %*% npc.0 %*% Wsqrt
evalues = eigen(V, symmetric = TRUE, only.values = TRUE)$values
evalues = replace(evalues, which(evalues <= 0), 0)
# npc = prespecified value for the number of principal components default = NULL
# pve = proportion of variance explained: used to choose the number of principal components.
npc = NULL
pve = 0.99
# for given pve we want to find npc
# if pcv > ncol(X), we should give a warning message!!!
#pcv and pve must be arguments
npc = ifelse(is.null(npc), min(which(cumsum(evalues)/sum(evalues) > pve)), npc)
npc
efunctions1
#now we can find eigenfunctions of Ktilde matrix
efunctions1 = matrix(Winvsqrt %*% eigen(V, symmetric = TRUE)$vectors[, seq(len = npc)],
nrow = D, ncol = npc)
efunctions1
efunctions
library(fpcaCor)
?fpcaCor
X = matrix(rnorm(1000), ncol = 25)
fpcaCor(X = X, types = "con", argvals = NULL, nbasis = 10, pve = 0.99, npc = NULL)
